# IllILevi.github.io


Here is the First code review: [![Module Two Code Review](https://img.youtube.com/vi/iahhYUW6S3Q/0.jpg)](https://youtu.be/iahhYUW6S3Q)

# Artifact One
[Artifact Enhancement One](https://github.com/IllILevi/CS-499-Computer-Science-Capstone/tree/main/CS-499_Enhancement_One)
The artifact I’ve chosen for this category is the from the IT-145: Foundation in Application Development project. This program helps keep track of search and rescue animals by taking them in, training them, and allowing for them to be reserved.
I chose this artifact because it showed my early understanding of object-oriented programming (OOP) in Java and I felt there was plenty of room to improve upon the original code. My enhancement plan involved converting this code into C++ as well as implementing industry-standard security principles. This goal wasn’t to simply convert a Java program into C++ syntax, but rather to center the program design in a way that is idiomatic to the C++ language. The skills showcased in doing this isn’t just simply proving I know two programming languages, instead, it shows that I have a strong understanding of software architecture and design, good problem solving skills, and a deep understanding of unique C++ features. The artifact was improved by making it more memory efficient and faster due to the nature of the two programming languages as well as adding proper input validation when appropriate.
The two course outcomes that I planned to meet for this category is as follows:
Develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources
Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution while managing the trade-offs involved in design choices.
I believe I have met both of these course outcomes with my enhancements.
Working on enhancing this artifact was quite the learning experience for me. I was already relatively comfortable with the C++ language, but this was my first time converting a program of this size to another programming language and since C++ is such a technical language, I certainly faced challenges along the way. For instance, how to best implement OOP principles that are still idiomatic to C++ or how to properly utilize and manage smart pointers and references. By encountering and overcoming these challenges, I’ve not only learned so much more about C++ and programming in general, I was able to further reinforce concepts that I’ve previously understood and implement them into the design.


# Artifact Two
[Artifact Enhancement Two](https://github.com/IllILevi/CS-499-Computer-Science-Capstone/tree/main/CS-499_Enhancement_Two)
The artifact I’ve chosen for this category is CS-300: DSA Analysis and Design. This program reads a file filled with courses and sorts them alphanumerically by course ID and prints it to the console. Then it further prompts the user to ask about a single course and it will print out the class along with its prerequisites. 
I chose this artifact because it showcases my understanding of different sorting algorithms not only from a conceptual standpoint but a practical one as well. It shows that I can consider the strengths and weaknesses of different data structures and algorithms and am able to justify using one over the other in order to find the most efficient one given the context of the program and my data. The artifact was improved by giving a practical demonstration on which sorting algorithm is the fastest in sorting two types of files: The original one that was in the class CS-300 called FileTest.csv and my own file, DummyData.txt that I created, which has a lot more courses (500 total). I also took the space complexity of sorting algorithms into consideration and found that Quick Sort was the best choice for the program.
The course outcome I believe I met with this enhancement is 
Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution while managing the trade-offs involved in design choices.  
I had never implemented Merge Sort before this artifact, so it was a process of figuring out how it worked conceptually and then how to implement it into my program. There was also, of course, the research phase on thinking about which sorting algorithm would be best in a theoretical sense. Thankfully, I didn't run into any serious challenges, this program is relatively straight forward. There was a small issue where almost all of the sorting algorithms were performing too quickly on the data to where the clock() function would only return 0 seconds, so I had to implement a high resolution clock to track the sorting process down to the microsecond.


